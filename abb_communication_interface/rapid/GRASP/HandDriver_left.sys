MODULE HandDriver(SYSMODULE)
! **************************************************** Start of description ****************************************************
! This file provides driver function and interface to operate the Hand via RAPID programming.
! This driver only work with EIO_H43_v3. Check the EIO version when loading it.
! This driver works with only Hand firmware v41. Check the firmware version when using it.
! ****************************************************
! FILE      HandDriver.sys              
! AUTHOR    Wenlong Li, Songlin Cai
! REVISION  1.10         For open Add-In
! HISTORY
!  2014.11.5   Created by Wenlong Li
!  2014.11.14  By wenlong li - Add the implementation of changing hand chirality via RAPID proc.
!  2014.12.1   By wenlong li - Modify the instructions of Hand_CastChirality as required by Songlin Cai,
!  2014.12.3   By wenlong li - Change module attributes to NOVIEW;  Add errnum for NOTCALIBRATED, 
!                              Delete the error handling for temporary communication-losing.
!  2014.12.4   By wenlong.li - Change Hand_Initialize, Hand_MoveXxx, Hand_GripXxxx proc.
!  2014.12.8   By wenlong.li - Modify the implementation of Hand_WaitForExpectedState and Hand_WaitMovingCompleted. 
!  2014.12.9   By wenlong.li - Add proc of Hand_TurnOnxxx, Hand_TurnOffxxxx for pneumatic modules and other minor changes. 
!
!  2015.2.11   By Songlin Cai -Hide server proc and fix some bugs
!  2015.3.6    By Songlin Cai -Replace errlog with  and change the errorid range to  2750-2799
!  2015.3.9    By Songlin Cai -Change the wrong error raise to ERR_HAND_FAILEDGRIPPOS in GripInward and GripOutward
!  2015.3.10   By Songlin Cai -Add eventlog to Hand_WaitMovingCompleted
!  2015.3.24   By wenlong li - fix the bug in Hand_ChangeChirality : no GoToReady sent before the changing operation
!  2015.3.24   By wenlong li - reimplement how to cast chirality. remove the local from Hand_ChangeChirality and Hand_CastChirality
!                                              - re-implement Hand_Initialize, removing flange power check and enabling.
!  2015.3.25   By wenlong li - Modify Hand_GripInward, Hand_GripOutward with new jog-like gripping method as default mode.
!  2015.3.25   By wenlong li - reset hand_PhysicalMaxPosition to 250.
!  2015.3.25   By songlin cai- Add waittime for jogopen and jogclose in GripInward and GripOutward
!  2015.4.2    By wenlong li - restore security key to 0 after changing chirality.
!  2015.5.6     By wenlong li - increase the poll rate in Hand_WaitForExpectedState from default 100ms to 10ms.
!  2015.05.12  By wenlong li - correct the error:  LOCAL is missed in hand_Chirality delcaration. It should be: LOCAL PERS string hand_Chirality:="R";     
!  2015.05.19  By  Fengqin Zhu -modify the custom error ID definition according to the license version. Add chage ErrLog to EventLog
!  2015.06.10  By  wenlong li - add tooldata for different gripper variants, with fingers/vacuum cup taken into account.
!  2015.06.12  By  wenlong li - NoWait option for Hand_GripXxward added. With that option, another gripping mechanism/FSM will be used. Normal gripping option will migrate to the new one if time is ok.
!                                                  Both gripping mechanism will use KeepObject to verify the completion of gripping.
! 2015.08.14   By wenlong li - Fix the error in Hand_SetHoldForce, Hand_SetMaxSpeed.
!                            - add error handler in Hand_Initialize to propagate the error to programmer's own error handler
!                            - remove the comments from Hand_GripXxward: No support for non-block mode in this procedure. The task should wait for the completion of this proc.
! 2015.08.17   By wenlong li - Add new optional argument \NotLimitDriveForce to Hand_GripXxward(), and change their implementation accordingly.
!                            - Change Hand_MoveTo(), removing the position check before Hand moving command and change ">" to ">=" in moving direction determining comparison.
! 2015.11.12   By wenlong li - update to 1.12.1
!                       - Add error raise in most instructions. In previous version there is no unconditional error propagation in Hand_MoveInward, Hand_MoveOutward, Hand_GripXxward. Such unconditional error propagation should be added.
!                       - in case of new command, Hand_WaitForExpectedState STATE_READY; will cause an error if previous buffered state is error. That is because RAPID execution speed could be faster then GoToReady cmd get a feedback from Gripper side.
!                       in new version , GoToReady will wait long enough to get State_Ready feedback., even the previous buffered state is State_Error.
! ****************************************************
! **************************************************** End of description ****************************************************


! Custom errnum definition.
VAR errnum ERR_HAND_WRONGSTATE := 51;
VAR errnum ERR_HAND_SYSERROR := 52;
VAR errnum ERR_HAND_FAILEDMOVE := 53;
VAR errnum ERR_HAND_FAILEDGRIP := 54;
VAR errnum ERR_HAND_NOTCALIBRATED := 55;
VAR errnum ERR_HAND_FAILEDVACUUM := 56;
VAR errnum ERR_HAND_FAILEDMOVEPOS := 57;
VAR errnum ERR_HAND_FAILEDGRIPINWARD := 58;
VAR errnum ERR_HAND_FAILEDGRIPOUTWARD := 59;
VAR errnum ERR_HAND_FAILEDGRIPPOS := 60;
VAR errnum ERR_HAND_AUGOUTOFRANGE:=61;
! Custom error ID definition, should be 2750-2799
!VAR num ERRID_HAND_WRONGSTATE := 5001;
!VAR num ERRID_HAND_SYSERROR := 5002;
!VAR num ERRID_HAND_FAILEDMOVE := 5003;
!VAR num ERRID_HAND_FAILEDGRIPINWARD := 5004;
!VAR num ERRID_HAND_NOTCALIBRATED := 5005;
!VAR num ERRID_HAND_FAILEDVACUUM := 5006;
!VAR num ERRID_HAND_INCORRECTPARAS := 5007;
!VAR num ERRID_HAND_FAILEDMOVEPOS := 5008;
!VAR num ERRID_HAND_FAILEDGRIPPOS := 5009;
!VAR num ERRID_HAND_FAILEDGRIPOUTWARD := 5010;
VAR num ERRID_HAND_WRONGSTATE := 2751;
VAR num ERRID_HAND_SYSERROR := 2752;
VAR num ERRID_HAND_FAILEDMOVE := 2753;
VAR num ERRID_HAND_FAILEDGRIPINWARD := 2754;
VAR num ERRID_HAND_NOTCALIBRATED := 2755;
VAR num ERRID_HAND_FAILEDVACUUM := 2756;
VAR num ERRID_HAND_INCORRECTPARAS := 2757;
VAR num ERRID_HAND_FAILEDMOVEPOS := 2758;
VAR num ERRID_HAND_FAILEDGRIPPOS := 2759;
VAR num ERRID_HAND_FAILEDGRIPOUTWARD := 2760;
! Error domain definition
VAR errdomain HandDriverErrDomain:=11;

! Constants indicating the commands for the hand
LOCAL CONST num COMMAND_JOGOPEN := 1;
LOCAL CONST num COMMAND_JOGCLOSE := 2;
LOCAL CONST num COMMAND_FREEMOVETOMAXPOS := 3;
LOCAL CONST num COMMAND_FREEMOVETOMINPOS := 4;
LOCAL CONST num COMMAND_GRIPOUTWARDIN := 5;
LOCAL CONST num COMMAND_GRIPINWARDOUT := 6;
LOCAL CONST num COMMAND_FORCINGOUTWARDIN := 7;
LOCAL CONST num COMMAND_FORCINGINWARDOUT := 8;
LOCAL CONST num COMMAND_GOTOERROR := 9;
LOCAL CONST num COMMAND_GOTOREADY := 10 ;
LOCAL CONST num COMMAND_GOTOCALIBRATION := 11;
LOCAL CONST num COMMAND_CHANGECHIRALITY := 14;
LOCAL CONST num COMMAND_AGILEGRIPINWARD := 15;	
LOCAL CONST num COMMAND_AGILEGRIPOUTWARD := 16;	
LOCAL CONST num COMMAND_CHANGECONFIRM := 29;	

!Constants indicating the states of the hand
LOCAL CONST num STATE_READY := 0;
LOCAL CONST num STATE_ERROR := 1;
LOCAL CONST num STATE_FREEMOVETOMAXPOS := 2;
LOCAL CONST num STATE_FREEMOVETOMINPOS := 3;
LOCAL CONST num STATE_GRIPMOVEOUTWARDIN := 4;
LOCAL CONST num STATE_GRIPMOVEINWARDOUT := 5;
LOCAL CONST num STATE_ACTIONCOMPLETED := 6;
LOCAL CONST num STATE_GRIPFORCINGOUTWARDIN := 7;
LOCAL CONST num STATE_GRIPFORCINGINWARDOUT := 8;
LOCAL CONST num STATE_KEEPOBJECT := 9;
LOCAL CONST num STATE_CALIBRATION := 10;
LOCAL CONST num STATE_JOGOPEN := 11;
LOCAL CONST num STATE_JOGCLOSE := 12;
LOCAL CONST num STATE_CHIRALITYCHANGING := 15;
LOCAL CONST num STATE_AGILEGRIPINWARD := 16;
LOCAL CONST num STATE_AGILEGRIPOUTWARD := 17;

! Signal definitions for gripper module and other system-level functions..
! GI as feedback
LOCAL VAR signalgi hand_ActualPosition;
LOCAL VAR signalgi hand_ActualSpeed;
LOCAL VAR signalgi hand_SysState;
LOCAL VAR signalgi hand_SysError;
LOCAL VAR signalgi hand_SoftwareVersion;
! GO for control
LOCAL VAR signalgo hand_SysCommand;
LOCAL VAR signalgo hand_MaxPosition;
LOCAL VAR signalgo hand_MinPosition;
LOCAL VAR signalgo hand_MaxSpeed;
LOCAL VAR signalgo hand_HoldForce;
LOCAL VAR signalgo hand_SecurityKey;
! DI as feedback
LOCAL VAR signaldi hand_Calibrated;
! DO for control
LOCAL VAR signaldo hand_ClearError;
! Used to control hand power on flange, It's DO in DSQC652 unit.
LOCAL VAR signaldo hand_FlangePower;

! Signal definitions for pneumatic module.
! GI as feedback
LOCAL VAR signalgi hand_ActualPressure1;
LOCAL VAR signalgi hand_ActualPressure2;
! DI as feedback
LOCAL VAR signaldi hand_StatusBlowoff1;
LOCAL VAR signaldi hand_StatusBlowoff2;
LOCAL VAR signaldi hand_StatusVacuum1;
LOCAL VAR signaldi hand_StatusVacuum2;
! DO for control
LOCAL VAR signaldo hand_CmdBlowoff1;
LOCAL VAR signaldo hand_CmdBlowoff2;
LOCAL VAR signaldo hand_CmdVacuum1;
LOCAL VAR signaldo hand_CmdVacuum2;

! Signal definitions for camera module
! DI as feedback.
LOCAL VAR signaldi hand_CamLinked;

! Hand's servo properties
LOCAL CONST num nMaxPositioningAllowance :=10;
LOCAL CONST num DEFAULT_MAXPOSITION := 200;
LOCAL CONST num DEFAULT_MINPOSITION := 20;
LOCAL CONST num DEFAULT_MAXSPEED := 200;
LOCAL CONST num DEFAULT_HOLDFORCE := 150;
LOCAL CONST num MAX_JOG_TIME := 2.5;
LOCAL CONST num MAX_WAIT_DURATION := 5;

! Hand system properties
LOCAL VAR num hand_PhysicalMaxPosition:=250;
LOCAL PERS string sForcedChirality := "BLANK";
LOCAL PERS string hand_Chirality:="L";
LOCAL VAR bool hand_IsChiralityUpdated := TRUE;
LOCAL VAR bool  hand_IsChiralityCasted := FALSE;

! Hand tooldata
TASK PERS tooldata tool_YuMiGripper_S := [TRUE, [[0, 0, 0], [1, 0, 0 ,0]], [0.230, [8.2, 11.7, 52.0], [1, 0, 0, 0], 0.00021, 0.00024, 0.00009]];
TASK PERS tooldata tool_YuMiGripper_S_V1 := [TRUE, [[0, 0, 0], [1, 0, 0 ,0]], [0.248, [8.6, 11.7, 52.7], [1, 0, 0, 0], 0.00021, 0.00024, 0.00009]];
TASK PERS tooldata tool_YuMiGripper_S_V1_V2 := [TRUE, [[0, 0, 0], [1, 0, 0 ,0]], [0.280, [7.1, 11.9, 47.3], [1, 0, 0, 0], 0.00025, 0.00029, 0.00012]];
TASK PERS tooldata tool_YuMiGripper_S_C := [TRUE, [[0, 0, 0], [1, 0, 0 ,0]], [0.244, [7.5, 11.8, 52.7], [1, 0, 0, 0], 0.00021, 0.00023, 0.00008]];
TASK PERS tooldata tool_YuMiGripper_S_C_V1 := [TRUE, [[0, 0, 0], [1, 0, 0 ,0]], [0.262, [7.8, 11.9, 50.7], [1, 0, 0, 0], 0.00022, 0.00024, 0.00009]];

! Variables definition for other utilities
VAR intnum int_HandFsmStateTransition;

!******************************************************!
!---------- RAPID driver routines start ---------------!
! For servo module
! Init the hand servo system.
PROC Hand_Initialize (\num maxSpd, \num holdForce, \num phyLimit, \switch Calibrate)
   VAR bool isTimeout := FALSE;

   ! Set the chirality firstly.
   hand_IsChiralityUpdated :=TRUE;
   Hand_SetupChirality;
   
   ! Check and turn on the flange power to hand.
   ! IF DOutput(hand_FlangePower)=0 THEN
      ! SetDO hand_FlangePower, 1;
   ! ENDIF   
       
   ! WaitUntil IOUnitState("Hand_"+hand_Chirality, \Phys) = IOUNIT_PHYS_STATE_RUNNING, \MaxTime := 60, \TimeFlag := isTimeout,\PollRate:=0.01;
   ! IF isTimeout=TRUE THEN
      ! This means the robot failed to setup the communication with hand.
      ! Todo, export this error into system error_event_system.
   
   ! ENDIF
   
   ! Update those parameters.
   IF Present(maxSpd) THEN
      Hand_SetMaxSpeed maxSpd;
   ELSE
      Hand_SetMaxSpeed 25;
   ENDIF

   IF Present (holdForce) THEN
      Hand_SetHoldForce holdForce;
   ELSE
      Hand_SetHoldForce 20;
   ENDIF

   IF Present(phyLimit) THEN
      hand_PhysicalMaxPosition := phyLimit*10;
   ELSE
      hand_PhysicalMaxPosition := 250;
   ENDIF

   ! Check and execute calibration process.
   IF Present(Calibrate) THEN
      Hand_DoCalibrate \Jog;
   ENDIF

ERROR
   Raise;
ENDPROC



PROC Hand_WaitForExpectedState (num expectedState, \num duration)
   VAR bool bIsTimeOut := FALSE;
   VAR num nWaitDuration := MAX_WAIT_DURATION;
   
   IF Present(duration) THEN
      nWaitDuration := duration;
   ENDIF
   WaitUntil (Hand_GetFingerState() = expectedState OR Hand_GetFingerState() = STATE_ERROR), \MaxTime := nWaitDuration, \TimeFlag := bIsTimeOut,\PollRate:=0.01;
   
   IF bIsTimeOut = TRUE OR Hand_GetFingerState() = STATE_ERROR THEN
      IF GOutput(hand_SysCommand) = COMMAND_GOTOREADY THEN
         WaitUntil Hand_GetFingerState() = STATE_READY, \MaxTime := nWaitDuration, \PollRate:=0.01;
      ELSE
         Raise ERR_HAND_WRONGSTATE;
      ENDIF      
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_WRONGSTATE THEN
      RAISE;
   ELSE
      RAISE;
   ENDIF
ENDPROC



! Jog the finger inward, with a time limit.
! The time limit linear to current setting of max speed.
PROC Hand_JogInward()
   VAR bool isJogToLimit := FALSE;
   
   Hand_SendCommand COMMAND_GOTOREADY;
   Hand_WaitForExpectedState STATE_READY;
   Hand_SendCommand COMMAND_JOGCLOSE;
   WaitTime 0.5;
   WaitUntil  Hand_GetActualSpd() < 1, \MaxTime := MAX_JOG_TIME * 200 / GOutput(hand_MaxSpeed), \TimeFlag := isJogToLimit,\PollRate:=0.01;
   Hand_Stop;   
ENDPROC



! Jog the finger outward, with a time limit.
PROC Hand_JogOutward()
   VAR bool isJogToLimit := FALSE;
   
   Hand_SendCommand COMMAND_GOTOREADY;
   Hand_WaitForExpectedState STATE_READY;
   Hand_SendCommand COMMAND_JOGOPEN;
   WaitTime 0.5;
   WaitUntil  Hand_GetActualSpd() < 1, \MaxTime := MAX_JOG_TIME * 200 / GOutput(hand_MaxSpeed), \TimeFlag := isJogToLimit,\PollRate:=0.01;
   Hand_Stop;    
ENDPROC



! Especially, wait for the Action_Completed state under those moving commands.
PROC Hand_WaitMovingCompleted (\switch Precise)
   VAR string dir;
   VAR string sOriginSignName;
   VAR signalgo signal_TargetPos;
   
   Hand_WaitForExpectedState STATE_ACTIONCOMPLETED;
ERROR
   IF ERRNO = ERR_HAND_WRONGSTATE THEN
      ! Probaly a waiting timeout caused by too slow moving speed. Re-wait a period.
      IF Hand_GetFingerState() <> STATE_ERROR THEN       
         IF GOutput(hand_MaxSpeed)<10 AND RemainingRetries()>3 THEN
            RETRY;
         else
             !ErrLog ERRID_HAND_FAILEDMOVEPOS,  ERRSTR_TASK,  hand_chirality , ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
			    EventLog HandDriverErrDomain,ERRID_HAND_FAILEDMOVEPOS, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED; 
             ! HandDriverErrDomain,ERRID_HAND_FAILEDMOVEPOS, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED; 
             Raise ERR_HAND_FAILEDMOVEPOS; 
         ENDIF         
      ELSE      
         ! Check whether an error state caused by motion precision.
         IF NOT Present(Precise) THEN
            ! Check whether under moving command.
            ! Actually for Hand_WaitMovingCompleted, it shall be under moving cmd. Check for robustness.
            IF ( GOutput(hand_SysCommand)>=3 AND GOutput(hand_SysCommand)<= 6) THEN
               IF GOutput(hand_SysCommand) = 4 OR GOutput(hand_SysCommand) = 5 THEN
                  dir := "Min";
               ELSE
                  dir := "Max";
               ENDIF
               sOriginSignName := "hand_" + dir + "Position_" + hand_Chirality;
               AliasIO sOriginSignName, signal_TargetPos;
               ! nMaxPositioningAllowance has no unit here. that is *0.1mm.     
               IF Abs(GInput(hand_ActualPosition)-GOutput(signal_TargetPos)) < nMaxPositioningAllowance THEN
                  ! If the positioning error is smaller than the allowance, igore this error.
                  !ErrLog ERRID_HAND_FAILEDMOVE, \W, ERRSTR_TASK, hand_chirality, ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;    
				  EventLog HandDriverErrDomain, ERRID_HAND_FAILEDMOVE, TYPE_WARN, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
                  ! HandDriverErrDomain, ERRID_HAND_FAILEDMOVE, TYPE_WARN, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
                  RETURN;         	
               ENDIF
               !ErrLog ERRID_HAND_FAILEDMOVEPOS,  ERRSTR_TASK,  hand_chirality , ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
			   EventLog HandDriverErrDomain,ERRID_HAND_FAILEDMOVEPOS, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
              !  HandDriverErrDomain,ERRID_HAND_FAILEDMOVEPOS, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED; 
              Raise ERR_HAND_FAILEDMOVEPOS;
            ENDIF
          else
              !ErrLog ERRID_HAND_FAILEDMOVEPOS,  ERRSTR_TASK,  hand_chirality , ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
			   EventLog HandDriverErrDomain,ERRID_HAND_FAILEDMOVEPOS, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED; 
              ! HandDriverErrDomain,ERRID_HAND_FAILEDMOVEPOS, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED; 
              Raise ERR_HAND_FAILEDMOVEPOS;     
                   
         ENDIF
      ENDIF      
   ENDIF  
ENDPROC



! Move the finger inward, with the as-is target position setting.
! It will only be called in Hand_MoveTo proc, now it's cannot be used standalone.
LOCAL PROC Hand_MoveInward ()
   Hand_SendCommand COMMAND_GOTOREADY;
   Hand_WaitForExpectedState STATE_READY;
   Hand_SendCommand COMMAND_FREEMOVETOMINPOS;
ERROR
   Raise;
ENDPROC



! Move the finger outward, with the as-is target position setting.
! It will only be called in Hand_MoveTo proc, now it's cannot be used standalone.
LOCAL PROC Hand_MoveOutward()
   Hand_SendCommand COMMAND_GOTOREADY;
   Hand_WaitForExpectedState STATE_READY;
   Hand_SendCommand COMMAND_FREEMOVETOMAXPOS;
ERROR
   Raise;
ENDPROC



! Move the finger to a designated position.
PROC Hand_MoveTo (num targetPos, \switch NoWait)
   VAR num currentPos := 0;
   VAR num originLimit := 0;
    
   ! Check whether calibrated.
   IF NOT Hand_IsCalibrated() THEN
     ! ErrLog ERRID_HAND_NOTCALIBRATED, ERRSTR_TASK, hand_chirality , ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;   
	 EventLog HandDriverErrDomain,ERRID_HAND_NOTCALIBRATED, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
     !  HandDriverErrDomain,ERRID_HAND_NOTCALIBRATED, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
      RAISE ERR_HAND_NOTCALIBRATED;   
      !ErrRaise "ERR_HAND_NOTCALIBRATED", 4811, "Hand not calibrated", ERRSTR_TASK, ERRSTR_CONTEXT, ERRSTR_UNUSED, ERRSTR_UNUSED;
      !ErrWrite \W, "Hand not calibrated", "Hand is not calibrated yet";
   ENDIF
   
   ! Check current position and determine how to move.
   currentPos := Hand_GetActualPos();
   
   ! the position check is removed for 
   ! 1 - the cmd of moving 0.1mm is actually OK
   ! 2 - such check introduces other bugs in some scenarios
   !IF Abs(currentPos-targetPos) < 0.2 THEN
   !   ! Too small gap, no need to move.
   !   RETURN;
   !ENDIF
   
   ! Check the required moving direction.
   ! the compasion is changed from ">" to ">=". See comments above.
   IF currentPos >= targetPos THEN
      Hand_SetMinPosition targetPos;
      Hand_MoveInward;
   ELSEIF currentPos < targetPos THEN
      Hand_SetMaxPosition targetPos;
      Hand_MoveOutward;
   ENDIF   
   
   ! Check whether needed to wait for the moving completed.
   IF NOT Present (NoWait) THEN
      Hand_WaitMovingCompleted;
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_NOTCALIBRATED THEN
      !Propagate the error to calling routine.
      Raise;
   ENDIF
   IF ERRNO = ERR_HAND_AUGOUTOFRANGE THEN
      !Propagate the error to calling routine.
      RAISE;
   ENDIF 
   IF ERRNO = ERR_HAND_FAILEDMOVEPOS THEN
      !Propagate the error to calling routine.
      Raise;
   ENDIF
ENDPROC



! Used to command the gripper to grip inward.
! If no new value of holdForce is assigned, the current initialized value will be used.
! posAlowance is omitted if targetPostion is not set.
! If not declared, posAllowance would be so large to make it useless.
PROC Hand_GripInward(\num holdForce, \num targetPos, \num posAlowance, \switch NoWait, \switch NotLimitDriveForce)
   VAR num maxGripPosErr;
   VAR num local_targetPos;
   ! Check whether calibrated.
   IF NOT Hand_IsCalibrated() THEN
      !ErrLog ERRID_HAND_NOTCALIBRATED, ERRSTR_TASK, hand_chirality , ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;  
	  EventLog HandDriverErrDomain,ERRID_HAND_NOTCALIBRATED, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
       ! HandDriverErrDomain,ERRID_HAND_NOTCALIBRATED, TYPE_ERR, ERRSTR_TASK, hand_chirality,ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;
      RAISE ERR_HAND_NOTCALIBRATED;
   ENDIF
   
   ! Set the holding force.
   IF Present(holdForce) THEN
      Hand_SetHoldForce holdForce;
   ELSE
      Hand_SetHoldForce 20;
   ENDIF
   
   IF Present(targetPos) THEN
      local_targetPos:=targetPos;
      IF Hand_GetActualPos() < targetPos THEN
         ! The target pos is larger than current pos. It's not possible to grip there with a inward force. 
         !ErrLog ERRID_HAND_FAILEDGRIPINWARD, ERRSTR_TASK,  ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED,ERRSTR_UNUSED;
         EventLog HandDriverErrDomain,ERRID_HAND_FAILEDGRIPINWARD, TYPE_ERR, ERRSTR_TASK,ERRSTR_CONTEXT, ERRSTR_UNUSED, ERRSTR_UNUSED,ERRSTR_UNUSED;
         ! HandDriverErrDomain,ERRID_HAND_FAILEDGRIPINWARD, TYPE_ERR, ERRSTR_TASK,ERRSTR_CONTEXT, ERRSTR_UNUSED, ERRSTR_UNUSED,ERRSTR_UNUSED;
         RAISE ERR_HAND_FAILEDGRIPINWARD;
      ELSE
         Hand_SetMinPosition targetPos;
      ENDIF
            
      IF Present(posAlowance) THEN
         maxGripPosErr := posAlowance;
      ELSE
         ! 1000 actually make this check useless.
         maxGripPosErr := 1000;
      ENDIF
   ELSE
      local_targetPos:=0;
      Hand_SetMinPosition 0;
      maxGripPosErr := 1000;
   ENDIF   

   IF NOT Present(NotLimitDriveForce) THEN
      Hand_SendCommand COMMAND_GOTOREADY;
      Hand_WaitForExpectedState STATE_READY;
      Hand_SendCommand COMMAND_AGILEGRIPINWARD;         
   ELSE
      Hand_SendCommand COMMAND_GOTOREADY;
      Hand_WaitForExpectedState STATE_READY;
      Hand_SendCommand COMMAND_GRIPOUTWARDIN;
      Hand_WaitForExpectedState STATE_GRIPMOVEOUTWARDIN;
      IF Present (NoWait) THEN
		IF OpMode() = OP_AUTO THEN
			CONNECT int_HandFsmStateTransition WITH trap_NowaitGripping;
			ISignalGI \Single, hand_SysState, int_HandFsmStateTransition;
		ELSE
			Hand_SendCommand COMMAND_FORCINGOUTWARDIN;
		ENDIF
      ELSE
        Hand_SendCommand COMMAND_FORCINGOUTWARDIN;
      ENDIF      
   ENDIF
   
   IF NOT Present(NoWait) THEN
      Hand_WaitForExpectedState STATE_KEEPOBJECT;
      
      ! Check whether the fingers grip the object in expected pos. 
      IF ABS(Hand_GetActualPos()-local_targetPos) > maxGripPosErr THEN
         !ErrLog ERRID_HAND_FAILEDGRIPPOS,  ERRSTR_TASK,  hand_Chirality , ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED ;     
         EventLog HandDriverErrDomain,ERRID_HAND_FAILEDGRIPPOS, TYPE_ERR, ERRSTR_TASK, hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
         !  HandDriverErrDomain,ERRID_HAND_FAILEDGRIPPOS, TYPE_ERR, ERRSTR_TASK, hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
         Raise ERR_HAND_FAILEDGRIPPOS; 
      ENDIF
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_WRONGSTATE THEN
      !Failed to keep object or error state.
      !Propagate the error to calling routine.
      Raise;
   ELSEIF ERRNO = ERR_HAND_NOTCALIBRATED THEN
      !Propagate the error to calling routine.
      Raise;
   ELSEIF ERRNO =ERR_HAND_AUGOUTOFRANGE THEN
       RAISE;
   ELSEIF ERRNO = ERR_HAND_FAILEDGRIPPOS THEN
      !Propagate the error to calling routine.
      Raise;
   ELSE
      Raise;
   ENDIF
ENDPROC



! Used to command the gripper to grip outward.
! If no new value of holdForce is assigned, the current initialized value will be used.
! posAlowance is omitted if targetPostion is not set.
! If not declared, posAllowance would be so large to make it useless.
PROC Hand_GripOutward(\num holdForce, \num targetPos, \num posAlowance, \switch NoWait, \switch NotLimitDriveForce)
   VAR num maxGripPosMargin;
   VAR num local_targetPos;
   ! Check whether calibrated.
   IF NOT Hand_IsCalibrated() THEN
      !ErrLog ERRID_HAND_NOTCALIBRATED, ERRSTR_TASK, hand_chirality , ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED;  
	  EventLog HandDriverErrDomain,ERRID_HAND_NOTCALIBRATED, TYPE_ERR, ERRSTR_TASK, hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
      ! HandDriverErrDomain,ERRID_HAND_NOTCALIBRATED, TYPE_ERR, ERRSTR_TASK, hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;

      RAISE ERR_HAND_NOTCALIBRATED;
   ENDIF
   
   ! Set the holding force.
   IF Present(holdForce) THEN
      Hand_SetHoldForce holdForce;
   ELSE
      Hand_SetHoldForce 20;      
   ENDIF
   
   IF Present(targetPos) THEN
        local_targetPos:=targetPos;
      IF Hand_GetActualPos() > targetPos THEN
         ! The target pos is smaller than current pos. It's not possible to grip there with a outward force. 
         !ErrLog ERRID_HAND_FAILEDGRIPOUTWARD,  ERRSTR_TASK, ERRSTR_CONTEXT, ERRSTR_UNUSED,ERRSTR_UNUSED,ERRSTR_UNUSED;
		  EventLog HandDriverErrDomain,ERRID_HAND_FAILEDGRIPOUTWARD, TYPE_ERR, ERRSTR_TASK,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED,ERRSTR_UNUSED;
        ! HandDriverErrDomain,ERRID_HAND_FAILEDGRIPOUTWARD, TYPE_ERR, ERRSTR_TASK,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED,ERRSTR_UNUSED;

        RAISE ERR_HAND_FAILEDGRIPPOS;
      ELSE
         Hand_SetMaxPosition targetPos;
      ENDIF
            
      IF Present(posAlowance) THEN
         maxGripPosMargin := posAlowance;
      ELSE
         ! 1000 actually make this check useless.
         maxGripPosMargin := 1000;
      ENDIF
   ELSE
      local_targetPos:=hand_PhysicalMaxPosition/10;
      Hand_SetMaxPosition local_targetPos;
      maxGripPosMargin := 1000;
   ENDIF 

   IF NOT Present(NotLimitDriveForce) THEN
      Hand_SendCommand COMMAND_GOTOREADY;
      Hand_WaitForExpectedState STATE_READY;
      Hand_SendCommand COMMAND_AGILEGRIPOUTWARD;         
   ELSE
      Hand_SendCommand COMMAND_GOTOREADY;
      Hand_WaitForExpectedState STATE_READY;
      Hand_SendCommand COMMAND_GRIPINWARDOUT;
      Hand_WaitForExpectedState STATE_GRIPMOVEINWARDOUT;
      IF Present (NoWait) THEN
		IF OpMode() = OP_AUTO THEN
			CONNECT int_HandFsmStateTransition WITH trap_NowaitGripping;
			ISignalGI \Single, hand_SysState, int_HandFsmStateTransition;
		ELSE
			Hand_SendCommand COMMAND_FORCINGINWARDOUT;
		ENDIF
      ELSE
        Hand_SendCommand COMMAND_FORCINGINWARDOUT;
      ENDIF
   ENDIF
   
   IF NOT Present(NoWait) THEN
      Hand_WaitForExpectedState STATE_KEEPOBJECT;
      
      ! Check whether the fingers grip the object in expected pos. 
      IF ABS(Hand_GetActualPos()-local_targetPos) > maxGripPosMargin THEN
        !ErrLog ERRID_HAND_FAILEDGRIPPOS,  ERRSTR_TASK,  hand_Chirality , ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED ;    
       EventLog HandDriverErrDomain,ERRID_HAND_FAILEDGRIPPOS, TYPE_ERR, ERRSTR_TASK,hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
       !  HandDriverErrDomain,ERRID_HAND_FAILEDGRIPPOS, TYPE_ERR, ERRSTR_TASK,hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
       Raise ERR_HAND_FAILEDGRIPPOS;
      ENDIF
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_WRONGSTATE THEN
      !Failed to keep object or error state.
      !Propagate the error to calling routine.
      Raise;
   ELSEIF ERRNO = ERR_HAND_NOTCALIBRATED THEN
      !Propagate the error to calling routine.
      Raise;
   ELSEIF ERRNO =ERR_HAND_AUGOUTOFRANGE THEN
       RAISE;
   ELSEIF ERRNO = ERR_HAND_FAILEDGRIPPOS THEN
      !Propagate the error to calling routine.
      Raise;
   ELSE
      Raise;
   ENDIF
ENDPROC 



! Execute the calibrating process.
! If Jog is not declared, the servo system will set the current pos to zero point.
PROC Hand_DoCalibrate (\switch Jog)
   ! Firstly jog the finger inward to mechanic limit. 
   IF Present(Jog) THEN
      Hand_JogInward;
      WaitTime 0.5;
   ENDIF

   Hand_SendCommand COMMAND_GOTOREADY;
   Hand_WaitForExpectedState STATE_READY;
   Hand_SendCommand COMMAND_GOTOCALIBRATION;
   Hand_WaitForExpectedState STATE_ACTIONCOMPLETED;
   Hand_SendCommand COMMAND_GOTOREADY;
ENDPROC


! Stop the gripper. 
PROC Hand_Stop ()
   Hand_SendCommand COMMAND_GOTOREADY;
   Hand_WaitForExpectedState STATE_READY;
   Hand_SendCommand 0;   
ENDPROC



! Setters and Getters. These are the proc/func that will operate the IOs directly.
! Setters.
! Send out finger servo command.
PROC Hand_SendCommand (num fingerCmdCode)
   Hand_SetupChirality;
   SetGO hand_SysCommand, fingerCmdCode;    
ENDPROC	



! Set the target max position in unit of mm.
local PROC Hand_SetMaxPosition (num maxPosInMm)
   VAR num maxPos; 
   ! For system internal use, convert the unit (*10).
   maxPos := Round(maxPosInMm*10);
   
   ! If maxPos is larger than the physical limit, set it to that physical limit.
   IF maxPos<0 OR maxPos > hand_PhysicalMaxPosition THEN
     ! maxPos := hand_PhysicalMaxPosition;
      !ErrLog ERRID_HAND_INCORRECTPARAS,  ERRSTR_TASK, hand_Chirality , ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED ;       
	  EventLog HandDriverErrDomain,ERRID_HAND_INCORRECTPARAS, TYPE_ERR, ERRSTR_TASK,hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
   !  HandDriverErrDomain,ERRID_HAND_INCORRECTPARAS, TYPE_ERR, ERRSTR_TASK,hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
    RAISE ERR_HAND_AUGOUTOFRANGE;
   else
      Hand_SetupChirality;
      SetGO hand_MaxPosition, maxPos;   
   endif
   ERROR
     IF ERRNO=ERR_HAND_AUGOUTOFRANGE THEN
         RAISE;
     ENDIF
     
ENDPROC



! Set the target min position in unit of mm
local PROC Hand_SetMinPosition (num minPosInMm)
   VAR num minPos; 
   ! For system internal use, convert the unit (*10).
   minPos := Round(minPosInMm*10);
   
   IF minPos<0 OR minPos>hand_PhysicalMaxPosition THEN
      ! Export this error and stop the program.
       !ErrLog ERRID_HAND_INCORRECTPARAS,  ERRSTR_TASK, hand_Chirality , ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED ; 
	   EventLog HandDriverErrDomain,ERRID_HAND_INCORRECTPARAS, TYPE_ERR, ERRSTR_TASK,hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
     ! HandDriverErrDomain,ERRID_HAND_INCORRECTPARAS, TYPE_ERR, ERRSTR_TASK,hand_Chirality,ERRSTR_CONTEXT,ERRSTR_UNUSED,ERRSTR_UNUSED;
     RAISE ERR_HAND_AUGOUTOFRANGE;
   else
       Hand_SetupChirality;
       SetGO hand_MinPosition, minPos;  
   ENDIF
 ERROR
    IF ERRNO=ERR_HAND_AUGOUTOFRANGE THEN
        RAISE;
   endif
    
ENDPROC




! Set the speed in unit of mm/s
PROC Hand_SetMaxSpeed (num maxSpdInMm)
   VAR num maxSpd;
   
   ! For system internal use, convert the unit (*10).
   maxSpd := Round(maxSpdInMm*10);
   
   IF maxSpd<30 THEN
      ! The max allowed speed is too samll, reset it to 3.
      maxSpd := 30;
   ENDIF
   
   IF maxSpd>250 THEN
      ! The Speed is too large, reset it to the maximum allowed spd.
      maxSpd := 250;
   ENDIF
   
   Hand_SetupChirality;
   SetGO hand_MaxSpeed, maxSpd;   
ENDPROC



! Set the hold force in unit of N.
PROC Hand_SetHoldForce (num holdForceInN)
   VAR num holdForce; 
   ! For system internal use, convert the unit (*10).
   holdForce := Round(holdForceInN*10);
   IF holdForce<0 THEN
      holdForce := 0;
   ENDIF
   IF holdForce>200 THEN
      ! The force is too large, reset it to max allowed value.
      holdForce := 200;
   ENDIF
   
   Hand_SetupChirality;
   SetGO hand_HoldForce, holdForce;    
ENDPROC



! Getters.
FUNC bool Hand_IsCalibrated ()
   Hand_SetupChirality;

   IF hand_Calibrated = 1 THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   ENDIF
ENDFUNC



! Read the link status of hand-held camera.
! Actually this check is completed by switch chip.
FUNC bool Hand_IsCamConnected ()
   Hand_SetupChirality;
   
   IF hand_CamLinked = 1 THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   ENDIF
ENDFUNC



! Read the gripper's pos in unit of mm.
FUNC num Hand_GetActualPos ()
   Hand_SetupChirality;
   RETURN (hand_ActualPosition/10);
ENDFUNC



! Read the gripper's real-time speed in uint of mm/s.
FUNC num Hand_GetActualSpd ()
   Hand_SetupChirality;
   RETURN (hand_ActualSpeed/10);    
ENDFUNC



! Read the gripper's current state.
FUNC num Hand_GetFingerState ()
   Hand_SetupChirality;
   RETURN (hand_SysState);
ENDFUNC



! Read the servo system's error ID.
FUNC num Hand_GetFingerErrID ()
   Hand_SetupChirality;
   RETURN (hand_SysError);  
ENDFUNC



! For pneumatic module
! Routines to control valves.
PROC Hand_TurnOnBlow1 ()
   Hand_SetupChirality;
   
   !Verify the corresponding vacuum valve is off.
   IF hand_StatusVacuum1 = 1 THEN
      SetDO hand_CmdVacuum1, 0;
   ENDIF
   WaitUntil hand_StatusVacuum1=0,\PollRate:=0.01;     
   SetDO hand_CmdBlowoff1, 1;
ENDPROC

PROC Hand_TurnOffBlow1 ()
   Hand_SetupChirality;   
   SetDO hand_CmdBlowoff1, 0;
ENDPROC

local PROC Hand_SwitchBlow1 (\switch On | switch Off )
   VAR num cmd := 0;
   
   Hand_SetupChirality;
   
   IF Present(On) THEN
      !Verify the vacuum valve off if we want to turn on blow valve
      IF hand_StatusVacuum1 = 1 THEN
         SetDO hand_CmdVacuum1, 0;
      ENDIF
      WaitUntil hand_StatusVacuum1=0,\PollRate:=0.01;
      cmd := 1;
   ELSEIF Present(Off) THEN
      cmd := 0;
   ENDIF
      
   SetDO hand_CmdBlowoff1, cmd;
ENDPROC



PROC Hand_TurnOnBlow2 ()
   Hand_SetupChirality;
   
   !Verify the corresponding vacuum valve is off.
   IF hand_StatusVacuum2 = 1 THEN
      SetDO hand_CmdVacuum2, 0;
   ENDIF
   WaitUntil hand_StatusVacuum2=0,\PollRate:=0.01;     
   SetDO hand_CmdBlowoff2, 1;
ENDPROC

PROC Hand_TurnOffBlow2 ()
   Hand_SetupChirality;   
   SetDO hand_CmdBlowoff2, 0;
ENDPROC

local PROC Hand_SwitchBlow2 (\switch On | switch Off)
   VAR num cmd := 0;
   
   Hand_SetupChirality;
   
   IF Present(On) THEN
      !Verify the vacuum valve off if we want to turn on blow valve
      IF hand_StatusVacuum2 = 1 THEN
      SetDO hand_CmdVacuum2, 0;
      ENDIF
      WaitUntil hand_StatusVacuum2=0,\PollRate:=0.01;
      cmd := 1;
   ELSEIF Present(Off) THEN
      cmd := 0;
   ENDIF
      
   SetDO hand_CmdBlowoff2, cmd;
ENDPROC



! threshold is the upper limit of the vacuum pressure in KPa.
PROC Hand_TurnOnVacuum1 (\num threshold)
   VAR bool bIsTimeOut := FALSE;
   
   Hand_SetupChirality;
   
   !Verify the corresponding vacuum valve is off.
   IF hand_StatusBlowoff1 = 1 THEN
      SetDO hand_CmdBlowoff1, 0;
   ENDIF
   WaitUntil hand_StatusBlowoff1=0,\PollRate:=0.01;     
   SetDO hand_CmdVacuum1, 1;
   
   IF Present(threshold) THEN
      WaitUntil Hand_GetVacuumPressure1() < threshold, \MaxTime := 1, \TimeFlag := bIsTimeOut,\PollRate:=0.01;
      IF bIsTimeOut = TRUE THEN
         Raise ERR_HAND_FAILEDVACUUM;
      ENDIF      
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_FAILEDVACUUM THEN
      RAISE;
   ENDIF    
ENDPROC

PROC Hand_TurnOffVacuum1 ()
   Hand_SetupChirality;   
   SetDO hand_CmdVacuum1, 0;
ENDPROC

local PROC Hand_SwitchVacuum1 (\switch On | switch Off, \num threshold)
   VAR num cmd := 0;
   VAR bool bIsTimeOut := FALSE;
   
   Hand_SetupChirality;
   
   IF Present(On) THEN
      !Verify the vacuum valve off if we want to turn on blow valve
      IF hand_StatusBlowoff1 = 1 THEN
      SetDO hand_CmdBlowoff1, 0;
      ENDIF
      WaitUntil hand_StatusBlowoff1=0,\PollRate:=0.01;
      cmd := 1;
   ELSEIF Present(Off) THEN
      cmd := 0;
   ENDIF
      
   SetDO hand_CmdVacuum1, cmd;
   IF Present(threshold) THEN
      WaitUntil Hand_GetVacuumPressure1() < threshold, \MaxTime := 1, \TimeFlag := bIsTimeOut,\PollRate:=0.01;
      IF bIsTimeOut = TRUE THEN
         Raise ERR_HAND_FAILEDVACUUM;
      ENDIF      
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_FAILEDVACUUM THEN
      RAISE;
   ENDIF    
ENDPROC



! threshold is the upper limit of the vacuum pressure in KPa.
PROC Hand_TurnOnVacuum2 (\num threshold)
   VAR bool bIsTimeOut := FALSE;
   
   Hand_SetupChirality;
   
   !Verify the corresponding vacuum valve is off.
   IF hand_StatusBlowoff2 = 1 THEN
      SetDO hand_CmdBlowoff2, 0;
   ENDIF
   WaitUntil hand_StatusBlowoff2=0,\PollRate:=0.01;     
   SetDO hand_CmdVacuum2, 1;
   
   IF Present(threshold) THEN
      WaitUntil Hand_GetVacuumPressure2() < threshold, \MaxTime := 1, \TimeFlag := bIsTimeOut,\PollRate:=0.01;
      IF bIsTimeOut = TRUE THEN
         Raise ERR_HAND_FAILEDVACUUM;
      ENDIF      
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_FAILEDVACUUM THEN
      RAISE;
   ENDIF 
ENDPROC

PROC Hand_TurnOffVacuum2 ()
   Hand_SetupChirality;   
   SetDO hand_CmdVacuum2, 0;
ENDPROC

local PROC Hand_SwitchVacuum2 (\switch On | switch Off, \num threshold)
   VAR num cmd := 0;
   VAR bool bIsTimeOut := FALSE;
   
   Hand_SetupChirality;
   
   IF Present(On) THEN
      !Verify the vacuum valve off if we want to turn on blow valve
      IF hand_StatusBlowoff2 = 1 THEN
      SetDO hand_CmdBlowoff2, 0;
      ENDIF
      WaitUntil hand_StatusBlowoff2=0,\PollRate:=0.01;
      cmd := 1;
   ELSEIF Present(Off) THEN
      cmd := 0;
   ENDIF
      
   SetDO hand_CmdVacuum2, cmd;
   IF Present(threshold) THEN
      WaitUntil Hand_GetVacuumPressure2() < threshold, \MaxTime := 1, \TimeFlag := bIsTimeOut,\PollRate:=0.01;
      IF bIsTimeOut = TRUE THEN
         Raise ERR_HAND_FAILEDVACUUM;
      ENDIF 
   ENDIF
ERROR
   IF ERRNO = ERR_HAND_FAILEDVACUUM THEN
      RAISE;
   ENDIF    
ENDPROC



! Get the fbk from vacuum sensor 1 in unit of bar.
FUNC num Hand_GetVacuumPressure1 ()  
   Hand_SetupChirality;
   return (hand_ActualPressure1);
ENDFUNC



! Get the fbk from vacuum sensor 2 in unit of bar.
FUNC num Hand_GetVacuumPressure2 ()   
   Hand_SetupChirality;
   return (hand_ActualPressure2);
ENDFUNC



! This proc will cast the hand chirality in its parent task to the assigned chirality. 
! chir could be either "L" or "R".
! The chirality won't be restored after execution.
PROC Hand_CastChirality (string chir)
   hand_Chirality := chir;
   hand_IsChiralityUpdated := TRUE;
   hand_IsChiralityCasted := TRUE;
   Hand_SetupChirality;
ENDPROC



! It's supposed that this proc would only be used by GUI.
PROC Hand_ChangeChirality (string chir)
   VAR num secKey := 0;
   Hand_SetupChirality;
   ! Determine the changing direction.
   IF hand_Chirality = "L" THEN
      secKey := 63;
   ELSEIF hand_Chirality = "R" THEN
      secKey := 46;
   ENDIF
   
   ! Only respond when special string is passed.
   IF chir = "cAsTCHircMd" THEN
      SetGO hand_SecurityKey, secKey;
      Hand_SendCommand COMMAND_GOTOREADY;
      Hand_WaitForExpectedState STATE_READY;
      SetGO hand_SysCommand, COMMAND_CHANGECHIRALITY;  
      Hand_WaitForExpectedState STATE_CHIRALITYCHANGING;
      SetGO hand_SysCommand, COMMAND_CHANGECONFIRM; 
      Hand_WaitForExpectedState STATE_ACTIONCOMPLETED;
      SetGO hand_SecurityKey, 0;
   ENDIF   
ENDPROC


! Support at most 2 hands now.
! By default, task1 will control right hand while task2 control left hand.
! GUI's parent task is supposed to have a special taskname.
local PROC Hand_SetupChirality ()
   VAR string config_io_string;   
   VAR num nCurTaskID := 0;
   VAR string curtaksnm;
    
   IF NOT hand_IsChiralityUpdated THEN
      RETURN;    
   ELSE
      IF hand_IsChiralityCasted = TRUE THEN
         hand_IsChiralityCasted := FALSE;
    ELSE
        curtaksnm := GetTaskName(\TaskNo := nCurTaskID);
        IF nCurTaskID = 1 THEN
        hand_Chirality := "R";
        ELSEIF nCurTaskID = 2 THEN
        hand_Chirality := "L";
    ENDIF  
      ENDIF
      hand_IsChiralityUpdated := FALSE;
      
      !Set alias IO for servo module and other system level signals.
      !config_io_string := "flange_24V_ROB_" + hand_Chirality;
      !AliasIO config_io_string, hand_FlangePower;     
      config_io_string := "hand_ActualPosition_" + hand_Chirality;
      AliasIO config_io_string, hand_ActualPosition;
      config_io_string := "hand_ActualSpeed_" + hand_Chirality;
      AliasIO config_io_string, hand_ActualSpeed;
      config_io_string := "hand_SysState_" + hand_Chirality;
      AliasIO config_io_string, hand_SysState;
      config_io_string := "hand_SysError_" + hand_Chirality;
      AliasIO config_io_string, hand_SysError;
      config_io_string := "hand_SoftwareVersion_" + hand_Chirality;
      AliasIO config_io_string, hand_SoftwareVersion;
      config_io_string := "hand_CmdGripper_" + hand_Chirality;
      AliasIO config_io_string, hand_SysCommand;
      config_io_string := "hand_MaxPosition_" + hand_Chirality;
      AliasIO config_io_string, hand_MaxPosition;
      config_io_string := "hand_MinPosition_" + hand_Chirality;
      AliasIO config_io_string, hand_MinPosition;
      config_io_string := "hand_MaxSpeed_" + hand_Chirality;
      AliasIO config_io_string, hand_MaxSpeed;
      config_io_string := "hand_HoldForce_" + hand_Chirality;
      AliasIO config_io_string, hand_HoldForce;
      config_io_string := "hand_StatusCalibrated_" + hand_Chirality;
      AliasIO config_io_string, hand_Calibrated;
      config_io_string := "hand_CmdClearErr_" + hand_Chirality;
      AliasIO config_io_string, hand_ClearError;
      config_io_string := "hand_SecurityKey_" + hand_Chirality;
      AliasIO config_io_string, hand_SecurityKey;
      
      
      ! Set alias IO for pneumatic module.
      config_io_string := "hand_CmdVacuum1_" + hand_Chirality;
      AliasIO config_io_string, hand_CmdVacuum1;
      config_io_string := "hand_CmdVacuum2_" + hand_Chirality;
      AliasIO config_io_string, hand_CmdVacuum2;
      config_io_string := "hand_CmdBlowoff1_" + hand_Chirality;
      AliasIO config_io_string, hand_CmdBlowoff1;
      config_io_string := "hand_CmdBlowoff2_" + hand_Chirality;
      AliasIO config_io_string, hand_CmdBlowoff2;
      config_io_string := "hand_StatusVacuum1_" + hand_Chirality;
      AliasIO config_io_string, hand_StatusVacuum1;	
      config_io_string := "hand_StatusVacuum2_" + hand_Chirality;
      AliasIO config_io_string, hand_StatusVacuum2;	
      config_io_string := "hand_StatusBlowoff1_" + hand_Chirality;
      AliasIO config_io_string, hand_StatusBlowoff1;	
      config_io_string := "hand_StatusBlowoff2_" + hand_Chirality;
      AliasIO config_io_string, hand_StatusBlowoff2;
      config_io_string := "hand_ActualPressure1_" + hand_Chirality;
      AliasIO config_io_string, hand_ActualPressure1;
      config_io_string := "hand_ActualPressure2_" + hand_Chirality;
      AliasIO config_io_string, hand_ActualPressure2;      

      ! Set alias IO for camera module.
      config_io_string := "hand_StatusCamLinked_" + hand_Chirality;
      AliasIO config_io_string, hand_CamLinked; 
   ENDIF
ENDPROC

TRAP trap_NowaitGripping 
   ! TPWrite "trap executed!";
   IF hand_SysState = STATE_ACTIONCOMPLETED THEN
      IF Goutput(hand_SysCommand) = COMMAND_GRIPOUTWARDIN THEN
         SetGO hand_SysCommand, COMMAND_FORCINGOUTWARDIN;
      ELSEIF Goutput(hand_SysCommand) = COMMAND_GRIPINWARDOUT THEN
         SetGO hand_SysCommand, COMMAND_FORCINGINWARDOUT;
      ENDIF      
   ENDIF
   
   IDelete int_HandFsmStateTransition;
   !TPWrite "int deleted!";
ENDTRAP

ENDMODULE
